"""
OrcaSlicer gcode metadata parser.

Extracts slicer settings and print metadata from OrcaSlicer-generated
gcode files. The metadata is embedded as comments in the gcode header
and config section.

OrcaSlicer gcode structure:
- HEADER_BLOCK: Contains slicer info, layer count, z-height
- THUMBNAIL_BLOCK: Base64 encoded thumbnails (skipped)
- EXECUTABLE_BLOCK: Actual gcode commands (skipped)
- Config section at end: Key-value pairs with slicer settings
"""

import re
from dataclasses import dataclass, field, asdict
from pathlib import Path
from typing import Optional, List, Dict


@dataclass
class GcodeMetadata:
    """
    Metadata extracted from OrcaSlicer gcode files.

    All fields are optional since not all slicers include all information.
    """

    # Slicer info
    slicer_name: Optional[str] = None
    slicer_version: Optional[str] = None

    # Layer settings
    layer_height: Optional[float] = None
    first_layer_height: Optional[float] = None
    layer_count: Optional[int] = None
    object_height: Optional[float] = None

    # Temperature settings
    nozzle_temp: Optional[int] = None
    bed_temp: Optional[int] = None

    # Speed settings
    print_speed: Optional[int] = None

    # Infill settings
    infill_percentage: Optional[int] = None
    infill_pattern: Optional[str] = None

    # Support settings
    support_enabled: Optional[bool] = None
    support_type: Optional[str] = None

    # Filament settings
    filament_type: Optional[str] = None
    filament_brand: Optional[str] = None
    filament_color: Optional[str] = None

    # Print estimates
    estimated_time: Optional[int] = None  # Seconds
    estimated_filament: Optional[float] = None  # Grams

    # Multi-filament usage and cost (Issue #5)
    filament_used_mm: Optional[List[float]] = None  # Per-extruder in mm
    filament_used_cm3: Optional[List[float]] = None  # Per-extruder in cmÂ³
    filament_used_g: Optional[List[float]] = None  # Per-extruder in grams
    filament_cost: Optional[List[float]] = None  # Per-extruder cost
    total_filament_used_g: Optional[float] = None  # Total across all extruders
    total_filament_cost: Optional[float] = None  # Total cost

    # Config block (Issue #5)
    config_block: Optional[Dict[str, str]] = None

    # Thumbnail (base64 encoded PNG)
    thumbnail_base64: Optional[str] = None

    # Raw metadata storage
    raw_metadata: dict = field(default_factory=dict)

    def to_dict(self) -> dict:
        """Convert metadata to dictionary."""
        return asdict(self)


class GcodeParser:
    """
    Parser for OrcaSlicer gcode metadata.

    Extracts slicer settings from comment lines in gcode files.
    """

    # Regex patterns for different metadata formats
    PATTERNS = {
        # Header format: "; key: value"
        "header": re.compile(r"^;\s*(.+?):\s*(.+?)$"),
        # Config format: "; key = value"
        "config": re.compile(r"^;\s*(.+?)\s*=\s*(.+?)$"),
        # Slicer info: "; generated by OrcaSlicer 2.3.1-dev on date"
        "slicer": re.compile(
            r"^;\s*generated by\s+(\w+)\s+([\d.]+[-\w]*)"
        ),
        # Estimated time: "; estimated printing time (normal mode) = 40m 34s"
        "time": re.compile(
            r"^;\s*estimated printing time \(normal mode\)\s*=\s*(.+?)$"
        ),
        # Filament used: "; filament used [g] = 9.85, 12.27, ..."
        "filament_used": re.compile(
            r"^;\s*filament used \[g\]\s*=\s*(.+?)$"
        ),
        # New filament metadata patterns (Issue #5)
        "filament_used_mm": re.compile(
            r"^;\s*filament used \[mm\]\s*=\s*(.+?)$"
        ),
        "filament_used_cm3": re.compile(
            r"^;\s*filament used \[cm3\]\s*=\s*(.+?)$"
        ),
        "filament_used_g": re.compile(
            r"^;\s*filament used \[g\]\s*=\s*(.+?)$"
        ),
        "filament_cost": re.compile(
            r"^;\s*filament cost\s*=\s*(.+?)$"
        ),
        "total_filament_used_g": re.compile(
            r"^;\s*total filament used \[g\]\s*=\s*(.+?)$"
        ),
        "total_filament_cost": re.compile(
            r"^;\s*total filament cost\s*=\s*(.+?)$"
        ),
        "config_block_start": re.compile(r"^;\s*CONFIG_BLOCK_START"),
        "config_block_end": re.compile(r"^;\s*CONFIG_BLOCK_END"),
        # Thumbnail begin: "; thumbnail begin 160x160 2452"
        "thumbnail_begin": re.compile(
            r"^;\s*thumbnail begin\s+(\d+)x(\d+)\s+(\d+)"
        ),
        # Thumbnail end: "; thumbnail end"
        "thumbnail_end": re.compile(r"^;\s*thumbnail end"),
    }

    # Field mappings from gcode key to metadata attribute
    FIELD_MAPPINGS = {
        "layer_height": "layer_height",
        "initial_layer_print_height": "first_layer_height",
        "nozzle_temperature": "nozzle_temp",
        "hot_plate_temp": "bed_temp",
        "outer_wall_speed": "print_speed",
        "sparse_infill_density": "infill_percentage",
        "sparse_infill_pattern": "infill_pattern",
        "support_type": "support_type",
        "filament_type": "filament_type",
        "filament_colour": "filament_color",
        "total layer number": "layer_count",
        "total layers count": "layer_count",
        "max_z_height": "object_height",
    }

    def __init__(self):
        """Initialize the parser."""
        pass

    def parse(self, content: str) -> GcodeMetadata:
        """
        Parse gcode content and extract metadata.

        Args:
            content: Raw gcode file content as string.

        Returns:
            GcodeMetadata with extracted values.
        """
        metadata = GcodeMetadata()
        raw_data = {}

        # Normalize line endings
        content = content.replace("\r\n", "\n").replace("\r", "\n")

        for line in content.split("\n"):
            line = line.strip()
            if not line.startswith(";"):
                continue

            # Try handlers in order of specificity
            if self._handle_slicer_info(metadata, line):
                continue
            if self._handle_estimated_time(metadata, line):
                continue
            if self._handle_filament_metadata(metadata, line):
                continue
            if self._handle_total_filament(metadata, line):
                continue
            if self._handle_config_or_header(metadata, raw_data, line):
                continue

        metadata.raw_metadata = raw_data

        # Extract thumbnail (separate pass for multi-line parsing)
        metadata.thumbnail_base64 = self._extract_thumbnail(content)

        # Extract config block (Issue #5)
        metadata.config_block = self._extract_config_block(content)

        return metadata

    def parse_file(self, file_path: Path) -> GcodeMetadata:
        """
        Parse a gcode file and extract metadata.

        Args:
            file_path: Path to the gcode file.

        Returns:
            GcodeMetadata with extracted values.

        Raises:
            FileNotFoundError: If the file does not exist.
        """
        file_path = Path(file_path)
        if not file_path.exists():
            raise FileNotFoundError(f"Gcode file not found: {file_path}")

        content = file_path.read_text(encoding="utf-8", errors="ignore")
        return self.parse(content)

    def _handle_slicer_info(self, metadata: GcodeMetadata, line: str) -> bool:
        """Handle slicer info extraction."""
        match = self.PATTERNS["slicer"].match(line)
        if match:
            metadata.slicer_name = match.group(1)
            metadata.slicer_version = match.group(2)
            return True
        return False

    def _handle_estimated_time(self, metadata: GcodeMetadata, line: str) -> bool:
        """Handle estimated time extraction."""
        match = self.PATTERNS["time"].match(line)
        if match:
            metadata.estimated_time = self._parse_time(match.group(1))
            return True
        return False

    def _handle_filament_metadata(self, metadata: GcodeMetadata, line: str) -> bool:
        """Handle multi-filament usage arrays (mm, cm3, g, cost)."""
        # filament used [mm]
        match = self.PATTERNS["filament_used_mm"].match(line)
        if match:
            metadata.filament_used_mm = self._parse_float_array(match.group(1))
            return True

        # filament used [cm3]
        match = self.PATTERNS["filament_used_cm3"].match(line)
        if match:
            metadata.filament_used_cm3 = self._parse_float_array(match.group(1))
            return True

        # filament used [g] - extract both array and first value for legacy field
        match = self.PATTERNS["filament_used_g"].match(line)
        if match:
            value_str = match.group(1)
            metadata.filament_used_g = self._parse_float_array(value_str)
            metadata.estimated_filament = self._parse_first_value(value_str, separator=",")
            return True

        # filament cost
        match = self.PATTERNS["filament_cost"].match(line)
        if match:
            metadata.filament_cost = self._parse_float_array(match.group(1))
            return True

        return False

    def _handle_total_filament(self, metadata: GcodeMetadata, line: str) -> bool:
        """Handle total filament values."""
        # total filament used [g]
        match = self.PATTERNS["total_filament_used_g"].match(line)
        if match:
            try:
                metadata.total_filament_used_g = float(match.group(1))
            except ValueError:
                pass
            return True

        # total filament cost
        match = self.PATTERNS["total_filament_cost"].match(line)
        if match:
            try:
                metadata.total_filament_cost = float(match.group(1))
            except ValueError:
                pass
            return True

        return False

    def _handle_config_or_header(
        self, metadata: GcodeMetadata, raw_data: dict, line: str
    ) -> bool:
        """Handle config and header format lines."""
        # Try config format: "; key = value"
        match = self.PATTERNS["config"].match(line)
        if match:
            key = match.group(1).strip()
            value = match.group(2).strip()
            raw_data[key] = value
            self._set_field(metadata, key, value)
            return True

        # Try header format: "; key: value"
        match = self.PATTERNS["header"].match(line)
        if match:
            key = match.group(1).strip()
            value = match.group(2).strip()
            raw_data[key] = value
            self._set_field(metadata, key, value)
            return True

        return False

    def _set_field(self, metadata: GcodeMetadata, key: str, value: str) -> None:
        """
        Set a metadata field based on the gcode key.

        Args:
            metadata: The metadata object to update.
            key: The gcode setting key.
            value: The raw value string.
        """
        field_name = self.FIELD_MAPPINGS.get(key)
        if not field_name:
            return

        try:
            setter = getattr(self, f"_set_{field_name}", None)
            if setter:
                setter(metadata, value)
        except (ValueError, TypeError):
            # If parsing fails, leave the field as None
            pass

    def _set_layer_height(self, metadata: GcodeMetadata, value: str) -> None:
        """Set layer height (float)."""
        metadata.layer_height = float(value)

    def _set_first_layer_height(self, metadata: GcodeMetadata, value: str) -> None:
        """Set first layer height (float)."""
        metadata.first_layer_height = float(value)

    def _set_nozzle_temp(self, metadata: GcodeMetadata, value: str) -> None:
        """Set nozzle temperature (first value from comma-separated)."""
        metadata.nozzle_temp = self._parse_first_int(value)

    def _set_bed_temp(self, metadata: GcodeMetadata, value: str) -> None:
        """Set bed temperature (first value from comma-separated)."""
        metadata.bed_temp = self._parse_first_int(value)

    def _set_print_speed(self, metadata: GcodeMetadata, value: str) -> None:
        """Set print speed (int)."""
        metadata.print_speed = int(float(value))

    def _set_infill_percentage(self, metadata: GcodeMetadata, value: str) -> None:
        """Set infill percentage (percent to int)."""
        metadata.infill_percentage = self._parse_percentage(value)

    def _set_infill_pattern(self, metadata: GcodeMetadata, value: str) -> None:
        """Set infill pattern (string)."""
        metadata.infill_pattern = value

    def _set_support_type(self, metadata: GcodeMetadata, value: str) -> None:
        """Set support type and enabled flag."""
        metadata.support_type = value
        metadata.support_enabled = value.lower() != "none"

    def _set_filament_type(self, metadata: GcodeMetadata, value: str) -> None:
        """Set filament type (first value from semicolon-separated)."""
        metadata.filament_type = self._parse_first_value(value, separator=";")

    def _set_filament_color(self, metadata: GcodeMetadata, value: str) -> None:
        """Set filament color (first value from semicolon-separated)."""
        metadata.filament_color = self._parse_first_value(value, separator=";")

    def _set_layer_count(self, metadata: GcodeMetadata, value: str) -> None:
        """Set layer count (int)."""
        metadata.layer_count = int(value)

    def _set_object_height(self, metadata: GcodeMetadata, value: str) -> None:
        """Set object height (float)."""
        metadata.object_height = float(value)

    def _parse_first_int(self, value: str) -> Optional[int]:
        """Parse the first integer from a comma-separated list."""
        first = self._parse_first_value(value, separator=",")
        if first:
            try:
                return int(float(first))
            except ValueError:
                return None
        return None

    def _parse_first_value(
        self, value: str, separator: str = ","
    ) -> Optional[float | str]:
        """
        Parse the first value from a separated list.

        Args:
            value: The raw value string.
            separator: The separator character.

        Returns:
            The first value as a float, or None if parsing fails.
        """
        if not value:
            return None

        parts = value.split(separator)
        if parts:
            first = parts[0].strip()
            try:
                return float(first)
            except ValueError:
                return first
        return None

    def _parse_percentage(self, value: str) -> Optional[int]:
        """Parse a percentage value like '15%' to integer 15."""
        value = value.strip().rstrip("%")
        try:
            return int(float(value))
        except ValueError:
            return None

    def _parse_time(self, time_str: str) -> Optional[int]:
        """
        Parse a time string to total seconds.

        Supports formats like:
        - "40m 34s"
        - "2h 30m 15s"
        - "1d 2h 30m"

        Args:
            time_str: The time string to parse.

        Returns:
            Total seconds, or None if parsing fails.
        """
        if not time_str:
            return None

        total_seconds = 0
        time_str = time_str.strip()

        # Parse days
        day_match = re.search(r"(\d+)d", time_str)
        if day_match:
            total_seconds += int(day_match.group(1)) * 86400

        # Parse hours
        hour_match = re.search(r"(\d+)h", time_str)
        if hour_match:
            total_seconds += int(hour_match.group(1)) * 3600

        # Parse minutes
        minute_match = re.search(r"(\d+)m", time_str)
        if minute_match:
            total_seconds += int(minute_match.group(1)) * 60

        # Parse seconds
        second_match = re.search(r"(\d+)s", time_str)
        if second_match:
            total_seconds += int(second_match.group(1))

        return total_seconds if total_seconds > 0 else None

    def _parse_float_array(
        self, value: str, separator: str = ","
    ) -> Optional[List[float]]:
        """
        Parse a comma-separated list of floats.

        Args:
            value: String like "9.85, 12.27, 0.00, 0.00"
            separator: Separator character.

        Returns:
            List of floats, or None if parsing fails.
        """
        if not value:
            return None

        try:
            parts = value.split(separator)
            return [float(p.strip()) for p in parts if p.strip()]
        except (ValueError, TypeError):
            return None

    def _extract_config_block(self, content: str) -> Optional[Dict[str, str]]:
        """
        Extract the entire CONFIG_BLOCK as a dictionary.

        OrcaSlicer places all slicer settings between:
        ; CONFIG_BLOCK_START
        ; setting_name = value
        ; CONFIG_BLOCK_END

        Args:
            content: Raw gcode file content.

        Returns:
            Dictionary of all config settings, or None if not found.
        """
        lines = content.split("\n")
        config = {}
        in_config_block = False

        for line in lines:
            line = line.strip()

            # Check for config block boundaries
            if self.PATTERNS["config_block_start"].match(line):
                in_config_block = True
                continue
            if self.PATTERNS["config_block_end"].match(line):
                break

            if in_config_block and line.startswith(";"):
                # Parse config line: "; key = value"
                config_match = self.PATTERNS["config"].match(line)
                if config_match:
                    key = config_match.group(1).strip()
                    value = config_match.group(2).strip()
                    config[key] = value

        return config if config else None

    def _extract_thumbnail(self, content: str) -> Optional[str]:
        """
        Extract the largest thumbnail from gcode content.

        OrcaSlicer embeds thumbnails as base64-encoded PNG images in comments:
        ; thumbnail begin WIDTHxHEIGHT BYTES
        ; [base64 lines...]
        ; thumbnail end

        Args:
            content: Raw gcode file content.

        Returns:
            Base64-encoded PNG data for the largest thumbnail, or None.
        """
        thumbnails = []
        lines = content.split("\n")
        i = 0

        while i < len(lines):
            line = lines[i].strip()
            begin_match = self.PATTERNS["thumbnail_begin"].match(line)

            if begin_match:
                width = int(begin_match.group(1))
                height = int(begin_match.group(2))
                base64_data, i = self._collect_thumbnail_data(lines, i + 1)

                if base64_data:
                    thumbnails.append((width, height, base64_data))

            i += 1

        if not thumbnails:
            return None

        # Select the largest thumbnail (by area)
        largest = max(thumbnails, key=lambda t: t[0] * t[1])
        return largest[2]

    def _collect_thumbnail_data(
        self, lines: List[str], start_index: int
    ) -> tuple[Optional[str], int]:
        """
        Collect base64 data from thumbnail block.

        Reads lines from start_index until "thumbnail end" is found,
        returning the concatenated base64 data and the index of the "thumbnail end" line.

        Args:
            lines: All content lines.
            start_index: Starting index to read from.

        Returns:
            Tuple of (base64_data, next_index) or (None, start_index) if no data found.
        """
        base64_lines = []

        for i in range(start_index, len(lines)):
            thumb_line = lines[i].strip()

            if self.PATTERNS["thumbnail_end"].match(thumb_line):
                break

            if thumb_line.startswith(";"):
                data = thumb_line[1:].strip()
                if data:  # Skip empty comment lines
                    base64_lines.append(data)

        base64_data = "".join(base64_lines) if base64_lines else None
        return base64_data, i
