"""
OrcaSlicer gcode metadata parser.

Extracts slicer settings and print metadata from OrcaSlicer-generated
gcode files. The metadata is embedded as comments in the gcode header
and config section.

OrcaSlicer gcode structure:
- HEADER_BLOCK: Contains slicer info, layer count, z-height
- THUMBNAIL_BLOCK: Base64 encoded thumbnails (skipped)
- EXECUTABLE_BLOCK: Actual gcode commands (skipped)
- Config section at end: Key-value pairs with slicer settings
"""

import re
from dataclasses import dataclass, field, asdict
from pathlib import Path
from typing import Optional


@dataclass
class GcodeMetadata:
    """
    Metadata extracted from OrcaSlicer gcode files.

    All fields are optional since not all slicers include all information.
    """

    # Slicer info
    slicer_name: Optional[str] = None
    slicer_version: Optional[str] = None

    # Layer settings
    layer_height: Optional[float] = None
    first_layer_height: Optional[float] = None
    layer_count: Optional[int] = None
    object_height: Optional[float] = None

    # Temperature settings
    nozzle_temp: Optional[int] = None
    bed_temp: Optional[int] = None

    # Speed settings
    print_speed: Optional[int] = None

    # Infill settings
    infill_percentage: Optional[int] = None
    infill_pattern: Optional[str] = None

    # Support settings
    support_enabled: Optional[bool] = None
    support_type: Optional[str] = None

    # Filament settings
    filament_type: Optional[str] = None
    filament_brand: Optional[str] = None
    filament_color: Optional[str] = None

    # Print estimates
    estimated_time: Optional[int] = None  # Seconds
    estimated_filament: Optional[float] = None  # Grams

    # Raw metadata storage
    raw_metadata: dict = field(default_factory=dict)

    def to_dict(self) -> dict:
        """Convert metadata to dictionary."""
        return asdict(self)


class GcodeParser:
    """
    Parser for OrcaSlicer gcode metadata.

    Extracts slicer settings from comment lines in gcode files.
    """

    # Regex patterns for different metadata formats
    PATTERNS = {
        # Header format: "; key: value"
        "header": re.compile(r"^;\s*(.+?):\s*(.+?)\s*$"),
        # Config format: "; key = value"
        "config": re.compile(r"^;\s*(.+?)\s*=\s*(.+?)\s*$"),
        # Slicer info: "; generated by OrcaSlicer 2.3.1-dev on date"
        "slicer": re.compile(
            r"^;\s*generated by\s+(\w+)\s+([\d.]+[-\w]*)"
        ),
        # Estimated time: "; estimated printing time (normal mode) = 40m 34s"
        "time": re.compile(
            r"^;\s*estimated printing time \(normal mode\)\s*=\s*(.+?)\s*$"
        ),
        # Filament used: "; filament used [g] = 9.85, 12.27, ..."
        "filament_used": re.compile(
            r"^;\s*filament used \[g\]\s*=\s*(.+?)\s*$"
        ),
    }

    # Field mappings from gcode key to metadata attribute
    FIELD_MAPPINGS = {
        "layer_height": "layer_height",
        "initial_layer_print_height": "first_layer_height",
        "nozzle_temperature": "nozzle_temp",
        "hot_plate_temp": "bed_temp",
        "outer_wall_speed": "print_speed",
        "sparse_infill_density": "infill_percentage",
        "sparse_infill_pattern": "infill_pattern",
        "support_type": "support_type",
        "filament_type": "filament_type",
        "filament_colour": "filament_color",
        "total layer number": "layer_count",
        "total layers count": "layer_count",
        "max_z_height": "object_height",
    }

    def __init__(self):
        """Initialize the parser."""
        pass

    def parse(self, content: str) -> GcodeMetadata:
        """
        Parse gcode content and extract metadata.

        Args:
            content: Raw gcode file content as string.

        Returns:
            GcodeMetadata with extracted values.
        """
        metadata = GcodeMetadata()
        raw_data = {}

        # Normalize line endings
        content = content.replace("\r\n", "\n").replace("\r", "\n")

        for line in content.split("\n"):
            line = line.strip()
            if not line.startswith(";"):
                continue

            # Try to extract slicer info
            slicer_match = self.PATTERNS["slicer"].match(line)
            if slicer_match:
                metadata.slicer_name = slicer_match.group(1)
                metadata.slicer_version = slicer_match.group(2)
                continue

            # Try to extract estimated time
            time_match = self.PATTERNS["time"].match(line)
            if time_match:
                metadata.estimated_time = self._parse_time(time_match.group(1))
                continue

            # Try to extract filament used
            filament_match = self.PATTERNS["filament_used"].match(line)
            if filament_match:
                metadata.estimated_filament = self._parse_first_value(
                    filament_match.group(1), separator=","
                )
                continue

            # Try config format: "; key = value"
            config_match = self.PATTERNS["config"].match(line)
            if config_match:
                key = config_match.group(1).strip()
                value = config_match.group(2).strip()
                raw_data[key] = value
                self._set_field(metadata, key, value)
                continue

            # Try header format: "; key: value"
            header_match = self.PATTERNS["header"].match(line)
            if header_match:
                key = header_match.group(1).strip()
                value = header_match.group(2).strip()
                raw_data[key] = value
                self._set_field(metadata, key, value)

        metadata.raw_metadata = raw_data
        return metadata

    def parse_file(self, file_path: Path) -> GcodeMetadata:
        """
        Parse a gcode file and extract metadata.

        Args:
            file_path: Path to the gcode file.

        Returns:
            GcodeMetadata with extracted values.

        Raises:
            FileNotFoundError: If the file does not exist.
        """
        file_path = Path(file_path)
        if not file_path.exists():
            raise FileNotFoundError(f"Gcode file not found: {file_path}")

        content = file_path.read_text(encoding="utf-8", errors="ignore")
        return self.parse(content)

    def _set_field(self, metadata: GcodeMetadata, key: str, value: str) -> None:
        """
        Set a metadata field based on the gcode key.

        Args:
            metadata: The metadata object to update.
            key: The gcode setting key.
            value: The raw value string.
        """
        field_name = self.FIELD_MAPPINGS.get(key)
        if not field_name:
            return

        try:
            if field_name == "layer_height":
                metadata.layer_height = float(value)
            elif field_name == "first_layer_height":
                metadata.first_layer_height = float(value)
            elif field_name == "nozzle_temp":
                metadata.nozzle_temp = self._parse_first_int(value)
            elif field_name == "bed_temp":
                metadata.bed_temp = self._parse_first_int(value)
            elif field_name == "print_speed":
                metadata.print_speed = int(float(value))
            elif field_name == "infill_percentage":
                metadata.infill_percentage = self._parse_percentage(value)
            elif field_name == "infill_pattern":
                metadata.infill_pattern = value
            elif field_name == "support_type":
                metadata.support_type = value
                metadata.support_enabled = value.lower() != "none"
            elif field_name == "filament_type":
                metadata.filament_type = self._parse_first_value(value, separator=";")
            elif field_name == "filament_color":
                metadata.filament_color = self._parse_first_value(value, separator=";")
            elif field_name == "layer_count":
                metadata.layer_count = int(value)
            elif field_name == "object_height":
                metadata.object_height = float(value)
        except (ValueError, TypeError):
            # If parsing fails, leave the field as None
            pass

    def _parse_first_int(self, value: str) -> Optional[int]:
        """Parse the first integer from a comma-separated list."""
        first = self._parse_first_value(value, separator=",")
        if first:
            try:
                return int(float(first))
            except ValueError:
                return None
        return None

    def _parse_first_value(
        self, value: str, separator: str = ","
    ) -> Optional[float | str]:
        """
        Parse the first value from a separated list.

        Args:
            value: The raw value string.
            separator: The separator character.

        Returns:
            The first value as a float, or None if parsing fails.
        """
        if not value:
            return None

        parts = value.split(separator)
        if parts:
            first = parts[0].strip()
            try:
                return float(first)
            except ValueError:
                return first
        return None

    def _parse_percentage(self, value: str) -> Optional[int]:
        """Parse a percentage value like '15%' to integer 15."""
        value = value.strip().rstrip("%")
        try:
            return int(float(value))
        except ValueError:
            return None

    def _parse_time(self, time_str: str) -> Optional[int]:
        """
        Parse a time string to total seconds.

        Supports formats like:
        - "40m 34s"
        - "2h 30m 15s"
        - "1d 2h 30m"

        Args:
            time_str: The time string to parse.

        Returns:
            Total seconds, or None if parsing fails.
        """
        if not time_str:
            return None

        total_seconds = 0
        time_str = time_str.strip()

        # Parse days
        day_match = re.search(r"(\d+)d", time_str)
        if day_match:
            total_seconds += int(day_match.group(1)) * 86400

        # Parse hours
        hour_match = re.search(r"(\d+)h", time_str)
        if hour_match:
            total_seconds += int(hour_match.group(1)) * 3600

        # Parse minutes
        minute_match = re.search(r"(\d+)m", time_str)
        if minute_match:
            total_seconds += int(minute_match.group(1)) * 60

        # Parse seconds
        second_match = re.search(r"(\d+)s", time_str)
        if second_match:
            total_seconds += int(second_match.group(1))

        return total_seconds if total_seconds > 0 else None
